#!/usr/bin/env bash
# ASCII Movie - Self-playing ASCII animation
# Generated by video2ascii
# Run with: ./this_file.sh [--loop] [--speed N] [--crt] [--progress]

set -euo pipefail

LOOP=0
SPEED="1.0"
CRT=0
PROGRESS=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --loop) LOOP=1; shift ;;
    --speed) SPEED="${2:-1.0}"; shift 2 ;;
    --crt) CRT=1; shift ;;
    --progress) PROGRESS=1; shift ;;
    -h|--help)
      echo "ASCII Movie Player"
      echo "Usage: $0 [--loop] [--speed N] [--crt] [--progress]"
      exit 0
      ;;
    *) shift ;;
  esac
done

# Embedded metadata (will be replaced by exporter)
ORIG_FPS=12
ORIG_CRT=0
TOTAL_FRAMES=0

# Calculate delay
FRAME_DELAY="$(awk "BEGIN {printf \"%.6f\", 1.0/($ORIG_FPS * $SPEED)}")"

# Use embedded CRT setting if --crt not explicitly passed
[[ "$CRT" -eq 0 ]] && CRT=$ORIG_CRT

# Colors
CRT_GREEN="\033[38;2;51;255;51m"
CRT_BG="\033[48;2;5;5;5m"
RESET="\033[0m"

cleanup() {
  printf "\033[?25h" || true
  printf "\033[0m" || true
  echo
}
trap cleanup EXIT

draw_progress() {
  local current=$1 total=$2 width=40
  local pct=$((current * 100 / total))
  local filled=$((current * width / total))
  local empty=$((width - filled))
  printf "\033[999;1H\033[K"
  [[ "$CRT" -eq 1 ]] && printf "${CRT_GREEN}"
  printf "["
  printf "%${filled}s" | tr ' ' '='
  printf "%${empty}s" | tr ' ' ' '
  printf "] %3d%% (%d/%d)" "$pct" "$current" "$total"
  [[ "$CRT" -eq 1 ]] && printf "${RESET}"
}

# Hide cursor and clear
printf "\033[?25l"
[[ "$CRT" -eq 1 ]] && printf "${CRT_BG}"
printf "\033[2J"

# Read and decompress frames from DATA section
play_once() {
  local frame_num=0
  local frame_content=""
  local in_frame=0
  
  # Read data section (avoid subshell by using process substitution)
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == "---FRAME---" ]]; then
      if [[ "$in_frame" -eq 1 && -n "$frame_content" ]]; then
        # Display previous frame
        ((frame_num++))
        printf "\033[H"
        [[ "$CRT" -eq 1 ]] && printf "${CRT_GREEN}"
        printf "%s" "$frame_content"
        [[ "$CRT" -eq 1 ]] && printf "${RESET}"
        [[ "$PROGRESS" -eq 1 ]] && draw_progress "$frame_num" "$TOTAL_FRAMES"
        sleep "$FRAME_DELAY"
      fi
      in_frame=1
      frame_content=""
    elif [[ "$in_frame" -eq 1 ]]; then
      # Decompress base64-encoded gzip data
      decoded_frame=$(echo "$line" | base64 -d | gunzip 2>/dev/null)
      if [[ -n "$decoded_frame" ]]; then
        frame_content="$decoded_frame"
      fi
    fi
  done < <(sed -n '/^__DATA__$/,$p' "$0" | tail -n +2)
  
  # Display last frame
  if [[ -n "$frame_content" && "$in_frame" -eq 1 ]]; then
    ((frame_num++))
    printf "\033[H"
    [[ "$CRT" -eq 1 ]] && printf "${CRT_GREEN}"
    printf "%s" "$frame_content"
    [[ "$CRT" -eq 1 ]] && printf "${RESET}"
    [[ "$PROGRESS" -eq 1 ]] && draw_progress "$frame_num" "$TOTAL_FRAMES"
    sleep "$FRAME_DELAY"
  fi
}

# Main loop
if [[ "$LOOP" -eq 1 ]]; then
  while true; do play_once; done
else
  play_once
fi

exit 0
__DATA__
