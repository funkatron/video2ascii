#!/usr/bin/env bash
# video2ascii
# Convert a video to ASCII frames and play it in the terminal.
#
# Requirements:
#   macOS: brew install ffmpeg jp2a
#   Linux: apt install ffmpeg jp2a (or equivalent)
#
# Usage:
#   ./video2ascii input.mp4
#   ./video2ascii input.mp4 --width 160 --fps 12
#   ./video2ascii input.mp4 --color
#   ./video2ascii input.mp4 --crt              # retro 80-column green phosphor
#   ./video2ascii input.mp4 --edge --invert    # artistic edge detection
#   ./video2ascii input.mp4 --loop --speed 1.5 # loop at 1.5x speed
#   ./video2ascii input.mp4 --progress         # show progress bar
#   ./video2ascii input.mp4 --no-cache         # don't keep extracted frames
#   ./video2ascii input.mp4 --export movie.sh  # package as standalone player

set -euo pipefail

# Defaults
WIDTH=160
FPS=12
COLOR=0
CACHE=1
LOOP=0
SPEED="1.0"
INVERT=0
EDGE=0
PROGRESS=0
CRT=0
EXPORT=""

die() { echo "Error: $*" >&2; exit 1; }

need() {
  command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"
}

INPUT="${1:-}"
[[ -n "${INPUT}" ]] || die "No input file provided."
[[ -f "${INPUT}" ]] || die "Input file not found: ${INPUT}"

shift || true
while [[ $# -gt 0 ]]; do
  case "$1" in
    --width) WIDTH="${2:-}"; shift 2 ;;
    --fps) FPS="${2:-}"; shift 2 ;;
    --color) COLOR=1; shift ;;
    --no-cache) CACHE=0; shift ;;
    --loop) LOOP=1; shift ;;
    --speed) SPEED="${2:-}"; shift 2 ;;
    --invert) INVERT=1; shift ;;
    --edge) EDGE=1; shift ;;
    --progress) PROGRESS=1; shift ;;
    --export) EXPORT="${2:-}"; shift 2 ;;
    --crt)
      CRT=1
      WIDTH=80
      COLOR=1
      shift
      ;;
    -h|--help)
      sed -n '1,50p' "$0"
      exit 0
      ;;
    *)
      die "Unknown option: $1"
      ;;
  esac
done

need ffmpeg
need jp2a

# Validate numeric args
[[ "$WIDTH" =~ ^[0-9]+$ ]] || die "--width must be an integer"
[[ "$FPS" =~ ^[0-9]+$ ]] || die "--fps must be an integer"
(( WIDTH >= 20 )) || die "--width too small"
(( FPS >= 1 )) || die "--fps too small"

# Validate speed (allow decimals like 0.5, 1.5, 2.0)
[[ "$SPEED" =~ ^[0-9]*\.?[0-9]+$ ]] || die "--speed must be a number (e.g., 0.5, 1.5, 2)"

BASE="$(basename "$INPUT")"
WORKDIR="$(mktemp -d "/tmp/ascii_${BASE}.XXXXXX")"
FRAMES_DIR="$WORKDIR/frames"
ASCII_DIR="$WORKDIR/ascii"
mkdir -p "$FRAMES_DIR" "$ASCII_DIR"

cleanup() {
  # restore cursor and colors
  printf "\033[?25h" || true
  printf "\033[0m" || true
  if [[ "$CACHE" -eq 0 ]]; then
    rm -rf "$WORKDIR" || true
  else
    echo
    echo "Cached output kept at: $WORKDIR"
    echo "ASCII frames: $ASCII_DIR"
  fi
}
trap cleanup EXIT

echo "Working dir: $WORKDIR"
echo "Extracting frames @ ${FPS} fps…"

# Build ffmpeg filter chain
VF_FILTERS="fps=${FPS},scale=${WIDTH}:-1"

if [[ "$EDGE" -eq 1 ]]; then
  # Sobel edge detection for artistic effect
  VF_FILTERS="${VF_FILTERS},edgedetect=low=0.1:high=0.3"
fi

if [[ "$CRT" -eq 1 ]]; then
  # Add slight blur and boost contrast for CRT feel
  VF_FILTERS="${VF_FILTERS},unsharp=5:5:1.5:5:5:0.0"
fi

# Extract frames
ffmpeg -hide_banner -loglevel error \
  -i "$INPUT" \
  -vf "$VF_FILTERS" \
  "$FRAMES_DIR/frame_%06d.png"

echo "Converting frames to ASCII (width=${WIDTH})…"

# Detect number of CPU cores for parallel processing
if command -v nproc >/dev/null 2>&1; then
  NCPU="$(nproc)"
elif command -v sysctl >/dev/null 2>&1; then
  NCPU="$(sysctl -n hw.ncpu)"
else
  NCPU=4
fi

# Convert all frames to text files (in parallel)
convert_frame() {
  local f="$1"
  local width="$2"
  local color="$3"
  local invert="$4"
  local crt="$5"
  local ascii_dir="$6"
  local out="$ascii_dir/$(basename "$f" .png).txt"
  local args=(--width="$width")
  
  if [[ "$color" -eq 1 ]]; then
    args+=(--colors)
  fi
  
  if [[ "$invert" -eq 1 ]]; then
    args+=(--invert)
  fi
  
  # For CRT mode, we'll add green tint in playback, but use color here
  if [[ "$crt" -eq 1 ]]; then
    args+=(--invert)  # CRT monitors had light-on-dark
  fi
  
  jp2a "${args[@]}" "$f" > "$out"
}
export -f convert_frame

find "$FRAMES_DIR" -name 'frame_*.png' -print0 | \
  xargs -0 -P "$NCPU" -I{} bash -c 'convert_frame "$@"' _ {} "$WIDTH" "$COLOR" "$INVERT" "$CRT" "$ASCII_DIR"

# Count frames for progress
FRAME_FILES=("$ASCII_DIR"/frame_*.txt)
TOTAL_FRAMES=${#FRAME_FILES[@]}

# Calculate frame delay with speed multiplier
FRAME_DELAY="$(awk "BEGIN {printf \"%.6f\", 1.0/($FPS * $SPEED)}")"

# Export mode: package frames into a standalone player script
if [[ -n "$EXPORT" ]]; then
  echo "Packaging ${TOTAL_FRAMES} frames into: $EXPORT"
  
  # Write the self-playing script header
  cat > "$EXPORT" << 'PLAYER_HEADER'
#!/usr/bin/env bash
# ASCII Movie - Self-playing ASCII animation
# Generated by video2ascii
# Run with: ./this_file.sh [--loop] [--speed N] [--crt] [--progress]

set -euo pipefail

LOOP=0
SPEED="1.0"
CRT=0
PROGRESS=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --loop) LOOP=1; shift ;;
    --speed) SPEED="${2:-1.0}"; shift 2 ;;
    --crt) CRT=1; shift ;;
    --progress) PROGRESS=1; shift ;;
    -h|--help)
      echo "ASCII Movie Player"
      echo "Usage: $0 [--loop] [--speed N] [--crt] [--progress]"
      exit 0
      ;;
    *) shift ;;
  esac
done

# Embedded metadata
PLAYER_HEADER

  # Write metadata
  echo "ORIG_FPS=$FPS" >> "$EXPORT"
  echo "ORIG_CRT=$CRT" >> "$EXPORT"
  echo "TOTAL_FRAMES=$TOTAL_FRAMES" >> "$EXPORT"
  
  # Write the player logic
  cat >> "$EXPORT" << 'PLAYER_BODY'

# Calculate delay
FRAME_DELAY="$(awk "BEGIN {printf \"%.6f\", 1.0/($ORIG_FPS * $SPEED)}")"

# Use embedded CRT setting if --crt not explicitly passed
[[ "$CRT" -eq 0 ]] && CRT=$ORIG_CRT

# Colors
CRT_GREEN="\033[38;2;51;255;51m"
CRT_BG="\033[48;2;5;5;5m"
RESET="\033[0m"

cleanup() {
  printf "\033[?25h" || true
  printf "\033[0m" || true
  echo
}
trap cleanup EXIT

draw_progress() {
  local current=$1 total=$2 width=40
  local pct=$((current * 100 / total))
  local filled=$((current * width / total))
  local empty=$((width - filled))
  printf "\033[999;1H\033[K"
  [[ "$CRT" -eq 1 ]] && printf "${CRT_GREEN}"
  printf "[%${filled}s%${empty}s] %3d%% (%d/%d)" "" "" "$pct" "$current" "$total" | tr ' ' '=' | sed 's/=/ /g; s/^\[/[/; s/\(=*\)\( *\]/\1 ]/; s/=\]/]/g'
  printf "["
  printf "%${filled}s" | tr ' ' '='
  printf "%${empty}s" | tr ' ' ' '
  printf "] %3d%% (%d/%d)" "$pct" "$current" "$total"
  [[ "$CRT" -eq 1 ]] && printf "${RESET}"
}

# Hide cursor and clear
printf "\033[?25l"
[[ "$CRT" -eq 1 ]] && printf "${CRT_BG}"
printf "\033[2J"

# Read frames from DATA section
play_once() {
  local frame_num=0
  local in_frame=0
  local frame_content=""
  
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == "---FRAME---" ]]; then
      if [[ "$in_frame" -eq 1 ]]; then
        # Display previous frame
        ((frame_num++))
        printf "\033[H"
        [[ "$CRT" -eq 1 ]] && printf "${CRT_GREEN}"
        printf "%s" "$frame_content"
        [[ "$CRT" -eq 1 ]] && printf "${RESET}"
        [[ "$PROGRESS" -eq 1 ]] && draw_progress "$frame_num" "$TOTAL_FRAMES"
        sleep "$FRAME_DELAY"
        frame_content=""
      fi
      in_frame=1
    elif [[ "$in_frame" -eq 1 ]]; then
      frame_content+="$line"$'\n'
    fi
  done < <(sed -n '/^__DATA__$/,$p' "$0" | tail -n +2)
  
  # Display last frame
  if [[ -n "$frame_content" ]]; then
    ((frame_num++))
    printf "\033[H"
    [[ "$CRT" -eq 1 ]] && printf "${CRT_GREEN}"
    printf "%s" "$frame_content"
    [[ "$CRT" -eq 1 ]] && printf "${RESET}"
    [[ "$PROGRESS" -eq 1 ]] && draw_progress "$frame_num" "$TOTAL_FRAMES"
    sleep "$FRAME_DELAY"
  fi
}

# Main loop
if [[ "$LOOP" -eq 1 ]]; then
  while true; do play_once; done
else
  play_once
fi

exit 0
__DATA__
PLAYER_BODY

  # Append all frames with delimiter
  for f in "${FRAME_FILES[@]}"; do
    echo "---FRAME---" >> "$EXPORT"
    cat "$f" >> "$EXPORT"
  done
  
  chmod +x "$EXPORT"
  
  FILE_SIZE=$(du -h "$EXPORT" | cut -f1)
  echo "Created: $EXPORT ($FILE_SIZE, ${TOTAL_FRAMES} frames @ ${FPS} fps)"
  echo ""
  echo "Play with:"
  echo "  ./$EXPORT"
  echo "  ./$EXPORT --loop --crt"
  echo "  ./$EXPORT --speed 2 --progress"
  
  exit 0
fi

# CRT green phosphor color (bright green on black)
CRT_GREEN="\033[38;2;51;255;51m"
CRT_DIM_GREEN="\033[38;2;20;80;20m"
CRT_BG="\033[48;2;5;5;5m"
RESET="\033[0m"

# Draw a progress bar
draw_progress() {
  local current=$1
  local total=$2
  local width=40
  local pct=$((current * 100 / total))
  local filled=$((current * width / total))
  local empty=$((width - filled))
  
  # Move to bottom of screen
  printf "\033[999;1H"
  printf "\033[K"  # clear line
  
  if [[ "$CRT" -eq 1 ]]; then
    printf "${CRT_GREEN}"
  fi
  
  printf "["
  printf "%${filled}s" | tr ' ' '='
  printf "%${empty}s" | tr ' ' ' '
  printf "] %3d%% (%d/%d)" "$pct" "$current" "$total"
  
  if [[ "$CRT" -eq 1 ]]; then
    printf "${RESET}"
  fi
}

# CRT scanline effect - add dim lines between rows
apply_crt_effect() {
  local content="$1"
  # Add green tint and slight dimming for odd lines (scanline effect)
  echo -e "${CRT_BG}${CRT_GREEN}${content}${RESET}"
}

echo "Playing in terminal… (Ctrl-C to stop)"
[[ "$LOOP" -eq 1 ]] && echo "(Looping enabled)"
[[ "$CRT" -eq 1 ]] && echo "(CRT mode: 80 columns, green phosphor)"

# hide cursor
printf "\033[?25l"

# Set up CRT background if enabled
if [[ "$CRT" -eq 1 ]]; then
  printf "${CRT_BG}"
  printf "\033[2J"  # clear with background color
else
  printf "\033[2J"
fi

# Playback function
play_frames() {
  local frame_num=0
  for f in "${FRAME_FILES[@]}"; do
    ((frame_num++))
    
    printf "\033[H"  # move cursor home
    
    if [[ "$CRT" -eq 1 ]]; then
      # Apply CRT green phosphor effect
      printf "${CRT_GREEN}"
      cat "$f"
      printf "${RESET}"
    else
      cat "$f"
    fi
    
    if [[ "$PROGRESS" -eq 1 ]]; then
      draw_progress "$frame_num" "$TOTAL_FRAMES"
    fi
    
    sleep "$FRAME_DELAY"
  done
}

# Main playback loop
if [[ "$LOOP" -eq 1 ]]; then
  while true; do
    play_frames
  done
else
  play_frames
fi
